# Chess Engine
### By Jaden Unruh, for Philosophy 401: Decision Theory

## How to use
Download the runnable file from the `Releases` portion of this GitHub page. Use the most recent release, the file will be located under `Assets`. Double-click the file to run. If nothing happens, contact me, as something is wrong. The expected behavior is that a window will open, directing the user to a browser, to the page http://localhost:8080. The app runs a local webserver. Keep the application window open, closing it will shut down the webserver. Visiting [the mentioned page](localhost:8080) should display a chessboard set up for the start of a game.

The top of the page will display a navigation bar that links to the project information and documentation (hosted by the webserver) and this GitHub page (obviously not hosted by the webserver). The information and documentation were automatically generated by [Maven](https://maven.apache.org/) and [javadoc](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javadoc.html), respectively, based on information in `pom.xml` and the project's `.java` files.

Below the board is a few controls for the computer's moves, and a button to fetch the current board state. It should update automatically, but if ever something seems to be going wrong, this will submit a request for the most recent board state.

To play, select the piece you'd like to move, and the board should highlight all the squares you can move it to. Select one of these to move the piece, or select another square to deselect the piece. After you've moved, use the slider to tell the computer how long you'd like to give it to move, and then select 'Get Computer Move' to tell the computer to begin. A message should appear below the buttons acknowledging the selection, and after the specified time (plus a little bit for server communications and overhead), a new message should appear containing information about the evaluation, and the move should be made on the board. Then, repeat, and play the game.

At the moment, there is no implementation for game endings, so 'win' by capturing all the computer's pieces, I guess. We're getting there.
## About the project
This project was made as a CYOA-style project for a class on Decision Theory. Of course, game engines are a little more game theory than decision theory, but there's definitely a good amount of overlap there. See the section below titled 'On Decision Making' for a more in-depth analysis of applying decision theory to this project.

Back in high school I made my first chess engine for a Computer Science 2 class. It wasn't very good, and it lacked many of the optimization features I used in this project. It was made fairly quickly, as we weren't given very long for our final projects. Ever since, I've wanted to revisit the project, knowing that I can do better, as I've come quite far in both programming ability and conceptual understanding of game theory, decision theory, and algorithmic problem-solving. This project served as my opportunity to do so.

The section below titled 'How Does it Work' has more details about the specific optimizations and techniques I used to improve over my previous version, but generally, I reduced overhead, implemented more efficient board state storage and methods, and wrote more concise, clear, and straightforwardly *better* code.
## Where is the Code?
The file tree above contains all of the project code, as well as boilerplate code generated by the IDE and [Spring Boot](https://en.wikipedia.org/wiki/Spring_Boot). The relevant files that I wrote include all of the back-end [`.java`](https://en.wikipedia.org/wiki/Java_(programming_language)) files located in [`src/main/java/org/j3lsmp/chessengine`](https://github.com/Jaden-Unruh/chess/tree/main/src/main/java/org/j3lsmp/chessengine), as well as the files that make up the front-end, written in [Svelte](https://en.wikipedia.org/wiki/Svelte), located in [`Front-End/chess-engine`](https://github.com/Jaden-Unruh/chess/tree/main/Front-End/chess-engine/src). In the executable that a user runs, the front-end files are compiled by Svelte into a single large [JavaScript](https://en.wikipedia.org/wiki/JavaScript) file. 
## How Does it Work
On application run, we boot the back-end using Spring, and open a small program window to direct the user to the main page hosted by the server. This small window is drawn with [Swing](https://en.wikipedia.org/wiki/Swing_(Java)) (not to be confused with Spring, which hosts the http server). I decided not to use Swing to run the entire app, though, as hosting through a browser provides a lot of tools (like the ability to easily use HTML/CSS/JS) that makes drawing the board state, handling user input, and all the boring stuff much easier - the point of this project was the computer algorithm, not making a game GUI.
### Front-end
When the user visits the game webpage (`localhost:8080`), a get request is sent to the webserver to fetch the most recent board state. This state was initialized to the start of a game. When they select a piece, another get request is sent to the server, asking for all available moves with that piece, and the response is drawn to the board. When they select one of those squares, a post request is sent, asking the server to move the selected piece to the selected square, and as long as that response comes back 'ok', we again fetch the board state with a get request.

When the button 'Get Computer Move' is pressed, we first send a get request to confirm it is the computer's move, and, if it is, we send a post request containing the selected computer time option. If this response comes back 'ok', it will contain data about the computer's move selection, like how many board states it considered and how 'deep' (moves ahead) it looked. We then again update board state with a get request. Note that the board state is not included in the response to our getComputerMove post request.

The update board button simply sends the same sort of get request to update board state, this can be pressed at any time.

The navigation bar simply contains links to static pages served by the backend for project information and documentation, and this GitHub page. Nothing interesting there.
### Back-end
This is where the real interesting stuff happens. I've broken this down into a few sections to simplify things
#### How does the computer store board states?
This is one of the biggest changes from the first time I made a chess engine. Instead of storing board states in a traditional 2D array, where each array index represents a square of the board and has a value according to which piece is there, we instead store a series of [bitboards](https://en.wikipedia.org/wiki/Bitboard), where each bitboard is a 64-bit value (in Java, these are [long](https://en.wikipedia.org/wiki/Integer_(computer_science)#Long_integer)s) that represents which squares on the board hold that particular characteristic. For example, we have a bitboard for each piece type, e.g. white pawns, where each bit in the `whitePawns` that is on (or 1, or true) means that the corresponding square contains a white pawn. In each of these bitboards, the 0th bit corresponds to a1, the 7th bit to h1, the 56th bit to a8, and the 63rd bit to h8. So, in a reset board, `whitePawns` is equal to 0x000000000000FF00, where bits 8 through 15 are on, and all of the others are off. In addition to a bitboard for each piece type, we also have bitboards for all of the white and black pieces, with on bits for the current location of every one of each player's pieces, as well as static/final bitboards representing certain regions of the board, like particular ranks or files, as well as bitboards that are calculated on initialization, like a bitboards for each square representing where a knight can move from that square, with on bits at each valid move from that square, and the same for kings. We also precompute bitboards representing linear and diagonal movement from each square, so we have 8 more bitboards for each square representing possible movement in each cardinal direction and each diagonal from that square. This sounds like a lot of data storage, but recall that each bitboard is only a 64 bit (8 byte) number, and all of the static/final bitboards (`KNIGHT_MOVES[]`, `RAYS_SOUTH[]`, etc.) are only generated and stored once. All of the bitboards to do with current game state (`whiteBishops`, `blackPieces`) are stored for every game state, both the active state that the user sees and every state considered by the computer as it chooses its move.
##### Why do we use bitboards?
Using bitboards allows for bitwise operations on board state, incredibly efficiently checking certain board characteristics and allowing us to greatly speed up operation times. The faster we can evaluate board states, generate sets of moves, and perform operations on the board, the more game states the computer can evaluate in its move search, which will result in deeper evaluations, and, ideally, better moves.

Traditional array representations of boards make many of these operations more difficult and slower. For example, modern processors contain hardware implementations to count ones in a memory object, which makes operations like counting how many of a particular piece a player has incredibly fast. To do so in an array would require looping through the array - much slower.

Bitboards are typically more memory-intensive (some bitboards may have only one on-bit with 63 off-bits, e.g. `blackKing`), but with modern computers the memory restriction is not significant - we're compute-bottle-necked, not memory-bottle-necked.
#### How does the computer evaluate board states?
This is handled by `ChessBoard#calculateBoardValue()`, which returns an integer. A return of 0 indicates that to the computer, this board is even - neither white nor black has an advantage. More positive values mean white is favored, and more negative values mean black is favored.

On a method call, the computer will first determine how many of each type of piece each player has - pawns are worth 100, knights 320, bishops 330, rooks 500, queens 900, and kings 20,000 points. White piece values are added and black values subtracted from the current evaluation. Then, positional values are taken into account. Each piece's position is compared to a table that weights value for having that piece in its particular location on the board. I've taken these tables from [a wiki article](https://www.chessprogramming.org/Simplified_Evaluation_Function) that details a similar evaluation function, as I'm not that good at chess so I don't know where pieces should be. In essence, though, you usually want to have pieces closer to the middle of the board, and it's ill-advised to keep a queen in the corner. Knights in particular are incredibly ineffective on the edges, so it's worthwhile to bring them to the middle. For each piece type, we calculate the sum of the piece weightings (which range from -50, knight in the corner, to +30, pawn on d5/e5), and add these values for white pieces, and subtract them for black. Note that for black pieces, we read these tables in reverse, as black plays on the board from the other side. Each table is symmetrical left/right so we don't worry about the opposite order in each rank for black pieces. These tables are all hard-coded in the interface `BoardFields.java`.
#### How does the computer choose a move?
Whenever the method `MoveSearcher#findBestMove(ChessBoard, long)` is called, the program will first log the time it started[^1], and then begin an iteratively-deepened minimax search using alpha-beta pruning and a transposition table. We'll dive into each of these terms to describe what they mean and how they're implemented.
##### Minimax
This means that the computer will evaluate each possible move it could make by seeing what moves the opponent could make in response. It assumes that the opponent will make its best possible move. This results in a recursive function where each player assumes the other will make the best move according to the same algorithm - thus, one player is minimizing the board evaluation, and the other maximizing it. We do this to a particular depth, and at that depth, we use the board evaluation function described above. Then, going back up the recursive cycle, each player chooses the move that either maximizes or minimizes this value, and thus the computer has made its decision. This is the central function that the computer uses to decide moves. However, it has a few flaws that we address with various additions to this:

 - to minimax to a pre-determined depth takes an indeterminate length of time - solved by iterative deepening
 - each deepening step introduces exponentially more board states to evaluate - addressed by alpha-beta pruning
 - many board states are reachable by multiple sets of moves - addressed by a transposition table
##### Iterative deepening
The user tells the computer how long it should take to choose a move, but minimax, particularly as we implement it with alpha-beta pruning, is inherently depth-first - that is, it evaluates each move to full depth before starting on the next. This means that if we cut it off at an arbitrary point in its evaluation, it may not have even considered the best move yet. So, we iteratively deepen the search. That is, we first evaluate all moves to depth 1, then again to depth 2, and so on, until we're out of time. I've set a maximum depth of 12, so if all moves are evaluated to this depth before the time limit, we return early, but this would be ridiculous - the computer usually reaches a depth of between 6 and 8 in my testing, depending on allotted time and board complexity. Perhaps in a late-game with very few pieces on the board we'd reach this, but as of writing this (between versions 0.0.1 and 0.0.2) I haven't played a game to the end yet.
##### Alpha-beta pruning
Alpha-beta pruning attempts to limit the search space by not evaluating to full depth moves that are already known to be worse than a previously checked move. For each player, we store the evaluation of the move that is determined to be best-so-far, at that depth. Then, if another possible move has a potential future that is worse for the current player at that depth, we don't need to continue evaluating the rest of its potential futures - that branch has been 'pruned'. This drastically reduces the number of board states we have to evaluate. As of writing this, I haven't yet implemented move ordering, where we first check moves that seem like they might be better (i.e. capturing an opponent's piece, promoting a pawn, developing pieces), but it's on my to-do list in future updates - this would make alpha-beta pruning more effective and allow us to prune more branches earlier.
##### Transposition table
Many board states can be reached by multiple series of moves - e.g  `1: e4 e5 2: Nf3 d5` yields the same state as `1: Nf3 e5 2: e4 d5`. However, minimax will have two separate branches for these states, despite all future evaluations yielding the same values. So, every time we evaluate a board state, we write the state and its associated evaluation (whether its an exact evaluation calculated to full-depth or an associate alpha-beta value due to pruning), as well as the depth it was calculated to, to a large table. Then, any time we reach the same board state, if we're not calculating to a greater depth, we can simply pull the value from the table, rather than repeating evaluations. However, as we discussed in 'How does the computer evaluate board states?', using bitboards as we are is incredibly memory-inefficient. During the course of a move search, we may investigate tens of millions of boards states, so to store bitboards for each piece type and more would quickly exhaust our memory limitations, and reading and writing so much to memory will slow the entire algorithm, potentially even more than leaving the lookup table out to begin with. So, for each board state, we perform a Zobrist hashing function, turning each board state into a single 64 bit value. This key then serves as a lookup value, allowing us to avoid storing the entire board[^2].

[^1]: We use `java.lang.System.currentTimeMillis()` for this. Admittedly, this leaves the program liable to things like leap seconds and users changing their system clock. However, a call to `System.nanoTime()` is slower, and I think such events are rare enough to disregard. Any error will only result in the computer stopping its search early, or running longer than expected.
[^2]: It's possible two different board states could have the same Zobrist hash. In this case, we may incorrectly pull a value for a different board state. However, a 64 bit key as we're using has over 18 quintillion possible values, and we hash *essentially* randomly, so it's incredibly unlikely. Evaluating even 100 million board states leaves little room for multiple repeats, and one or two incorrect table reads is unlikely to cause the computer to make a particularly notably bad move.
#### How does the computer handle requests from the front-end?
This is easily performed by Spring Boot. We receive HTTP requests, parse them, call the relevant methods and fetch the relevant data, and respond with a ResponseEntity object as provided by the Spring framework. The relevant code for this is handled within the file `APIController.java`, that class is marked as a Rest Controller and handles all requests sent to `localhost:8080/api`. Below is a list of all API mappings and a brief description of what they do:
##### `/api/getMoves/{square}`
This responds with all the moves that can be made from the specified square, which is detailed as an integer between 0 and 63. A HashSet of integers will be returned as a json, where each integer is a value between 0 and 63 that the piece on the specified square can legally move to. This method calls `ChessBoard#generateMoves()` to determine these values.
##### `/api/getBoard`
This responds with the current board state in array form - meaning we do a conversion from bitboards. Specifically, it's a list of list of bytes, as these are easier to convert to json for the response than arrays proper. The conversion is handled by `ChessBoard#boardAsArray()`.
##### `/api/makeMove`
This accepts post requests with a body containing integers detailing a from square and a to square (values between 0 and 63), and an integer between -6 and 6 detailing piece type (negative are black pieces, positive white pieces, and absolute values of 1-6 are pawns, knights, bishops, rooks, queens, and kings). These are passed to a MoveRequest object and then performed on the board.
##### `/api/isComputerTurn`
This responds simply with a boolean of whether or not it is the computer's turn.
##### `/api/computerMove`
This accepts post requests with a body containing an integer that is how many milliseconds to allocate to the computer's move computation. The method then calls `MoveSearcher#findBestMove()` with the current game board and the specified time limit, and performs this move. It finally responds with a body containing data about the move search - boards evaluated, game states considered, and the final depth it reached before the time limit.
## On Decision Making
This project was, as I mentioned, for a Decision Theory class, within the Philosophy department. This project, though, kind of feels more like a CS project. So, in this section, I'll detail a couple themes we've discussed in Phil 401 and how they're reflected in this project, and how different models of decision-making can be applied to what the computer's doing.
### Subjective Expected Utility Theory
Recently, we've discussed the idea of expected value - the sum of the values of all potential outcomes multiplied by how likely they are. Or, if we complicate things a bit, the sum of an agent's values from their utility function multiplied by the corresponding values of their probability function. In the context of this computer algorithm, the computer is faced with a decision tree with millions of outcomes, and it assigns to each outcome a utility - the result of the method `#calculateBoardValue()` is the computer's utility function. The probability function is a little more hidden - it's not simply a method. But, in the way we use minimax, the computer deems the 'most likely' outcome to be the move that either maximizes or minimizes the utility function depending on whose turn it is. Thus, in 'multiplying' these values, the computer makes a decision that cascades up the tree, choosing the best move for the relevant player at each step, and using the resultant decision in the next stage up the tree.
### Dominance Theory
The principles of dominance theory (sort of) explain why alpha-beta pruning works. Once a branch of the move-tree has been evaluated to full depth, any subsequent branches may not need to be analyzed fully. If a move is found to have a response that guarantees a worse evaluation than a fully analyzed move, that move is 'dominated' - it is guaranteed to produce a worse outcome. The computer considers that response that guarantees a worse outcome to be nearly certain (it assumes the opposing player will play exactly the same way the current player does, but with opposite SEU functions)[^3]. Thus, we do not choose the dominated decision, and continue evaluating other moves.
[^3]: The opposite player may play a move that is even worse (for the current player) than this discovered response, but that just means that the considered move is even more dominated.
## Troubleshooting
For the most part, if anything goes wrong, just let me know. As of writing this, the project is in a very beta release, so expect missing features, bugs, and unexpected behaviors. Nevertheless, there are a few things you can do if things go wrong.
> Link on application window doesn't open a browser

Simply open a browser manually and navigate to [localhost:8080](http://localhost:8080). This can happen sometimes if the program cannot detect a default browser, or encounters an error in opening the browser.
___
> The board isn't updating as expected

At any point, you can press the `Update Board` button to fetch the newest board state from the server. This will always update the board appropriately, and will update the locally-stored value of `isComputerTurn`, meaning that if it's your turn, it will enable the ability to select pieces, and if not, it will allow you to press the `Get Computer Move` button.
___
> My computer flags this as a virus

I pinkie-promise this is not a virus. It costs money to sign an executable file with a Certificate Authority, and I don't really want to purchase that for this project. So, the files are all unsigned and sometimes Windows, MacOS, and various antivirus software don't like that. However, feel free to download the files from GitHub and compile it yourself - this is part of why I included files like `pom.xml` so that you can use Maven to compile locally, allowing you to look through all the files and ensure nothing malicious is contained.
___
> Pretty much anything else goes wrong

As I said, this project is in a very beta version. So, if you encounter any bugs, please let me know. I can implement a fix to solve them, or help you find a workaround.
